# Database Schema Design

## What is a DBMS

To manage digital databases we use specialized software called Database Management Systems (DBMS). These systems typically run on servers and are managed by Database Administrators (DBAs).

In less technical terms, we need a type of software that will allow us to create, access, and generally manage our databases. In the world of relational databases, we specifically use Relational Database Management Systems (RDBMs). Some examples are Postgres, SQLite, MySQL, and Oracle.

Choosing a DBMS determines everything from how you set up your database, to where and how the data is stored, to what SQL commands you can use. Most systems share the core of the SQL language that we've learned.

In other words, you can expect **SELECT, UPDATE, INSERT, WHERE** and the like to be the same across all DBMSs, but the subtleties of the language may vary.

## What is SQLite?

SQLite is the DBMS that will be used in this module. It is more of a lightweight system and thus easier to setup than some others.

SQLite is not a database (like relational, graph, or document are databases) but rather a database management system.

## Opening an existing database in SQLite Studio

One useful visual interface we might use with a SQLite database is called SQLite Studio

Once installed, we can use it to open any .db3 file and view the tables, data, and even make changes in the database.

## Database Schema

A database schema is the shape of our database. It defines what tables we'll have, which columns should exist within the tables and any restriction son each column.

A well-designed database schema keeps the data well organized and can help ensure high quality data.

Note that while schema design is usually left to the Database Administrators, understanding schema helps when designing APIs and database logic. And in a smaller team, this step may fall on the developer.

## Follow along: Schema Design

When designing a single table, we need to ask three things:

* What fields (or columns) are present?
* What type of data do we expect for each field?
* Are there other restrictions needed for each column?

Looking at the following schema diagram for an accounts table, we can answer those questions.

| field   | datatype      | metadata |
| --------|---------------|--------- |
|id       | unsigned integer | primary key, auto increments, generated by database |
| name | string | required, unique |
|budget | numeric | required |

## Table Fields

Choosing which fields to include in a table is relatively straight forward. What information needs to be tracked  regarding this resource? In the real world is determined by the intended use of the product or app.

However, this is one of the requirements every table should satisfy: a primary key. A primary key is a way to identify each entry in the database uniquely. It is often represented as an auto incrementing integer called **id**.

## Datatypes

Each field must also have a specified datatype. The datatype depends on the DBMS. Some supported datatype in SQLite includes:

* **Null**: Missing or unknown information
* **Integer**: Whole numbers
* **Real**: Any number, including decimals
* **Text**: Character data.
* **Blob**: a large binary object that can be used to store miscellaneous data.

Any data inserted into the table must match the datatypes determined in schema design.

## Constraints

Beyond datatypes, we may add additional constraints on each field. Some examples are:

* **Not Null**: This field cannot be left empty
* **Unique**: No two resource can have the same value in this field
* **Primary Key**: Indicates this field is the primary key. Both the not null and unique constraints will be enforced.
* **Default**: Sets a default value if none is provided.

As with data types, any data that does not satisfy the schema design will be rejected from the database.

## Multi-Table Design:

Another critical component of schema design is to understand how different table relates to each other.

## Overview

Knex provides a schema builder, which allows us to write code to design our database schema. However, beyond thinking about columns and constraints, we must also consider updates.

When a schema needs to be updated, a developer must feel confident that the changes go into effect everywhere. This means schema updates on the developer's local machine, on any testing or staging versions, on the production databases, and then on any other developer's local machines. This is where **migrations** come into play.

A **database migration** describes changes made to the structure of a database. Migrations include things like adding a new objects, adding a new table, and modifying existing objects or tables.

## Follow Along - Knex CLI

Knex CLI

To use migration (and to make Knex setup easier), we need to use knex cli. Install knex globally with:

```
npm install -g knex
```

This allows you to use Knex commands with any repo that has knex as a local dependency. If you have any issues with this global install, you can use the **npx knex** command instead.

## Initializing Knex

To start, add the **knex** and **sqlite3** libraries to your repository.

```
npm install knex sqlite3
```

We've seen how to manually create a config object to get started with Knex, but the best practice is to use the following command:

```
knex init
```

Or if knex isn't globally installed;

```
npx knex init
```

This command will geneate a file in your root folder called **knexfile.js**. It will be autopopulated with three config objects, based on different environments. We can delete all except for the development object.

```
module.exports = {
  development: {
    client: 'sqlite3',
    connection: {
      filename: './dev.sqlite3'
    }
  }
};
```

We'll need to update the location (or desired location) of the database as well as add the **useNullAsDefault** option. The latter option prevents crashes when working with sqlite3.

```
module.exports = {

  development: {
    // our DBMS driver
    client: 'sqlite3',
    // the location of our db
    connection: {
      filename: './data/database_file.db3',
    },
    useNullAsDefault: true
  }

};
```

Now whereever we configure our database, we may use the following syntax instead of hardcoding in a config object.

```
const knex = require('knex');

const config = require('../knexfile.js');

// we must select the development object from our knexfile
const db = knex(config.development);

// export for us in codebase
module.exports = db;
```

## Knex Migrations

Once our **knexfile** is set up, we can begin creating migrations. Though it's not requried, we are going to add an addition option to the config object to specify a directory for the migration files.

```
development: {
  client: 'sqlite3',
  connection:{
    filename: './data/produce.db3'
  },
  useNullAsDefault: true,
  // generate migration files in a data/migrations/ folder
  migration: {
    directory: './data/migrations'
  }
}
```

We can generate a new migration with the following command:

```
knex migrate:make [migration-name]
```

If we needed to create an accounts table, we might run:

```
knex migrate:make create-accounts
```

Note that inside **data/migrations/**, a new file has appeared. Migrations have a timestamp in their filenames automatically whether you like it or not, do not edit the migration names.

The migration file should have both an **up** and **down** function. Within the up function, we write the ended database changes. Within the down function, we write code to undo the up function. This allows us to undo any changes made to the schema if necessary.

```
exports.up = function(knex, Promise) {
  // don't forget the return statement
  return knex.schema.createTable('accounts', tbl => {
    // creates a primary key called id
    tbl.increments();
    // creates a text field called name which is both required and unique
    tbl.text('name', 128).unique().notNullable();
    // creates a numeric field called budget which is required
    tbl.decimal('budget').notNullable();
  });
};

exports.down = function(knex, Promise) {
  // drops the entire table
  return knex.schema.dropTableIfExists('accounts');
};
```

You can refer to the methods in the schema builder section of the knex documentation.

At this point, the tables is not yet created. To run this (and any other) migrations, we use the command:

```
knex migrate:latest
```

Note if the database does not exist, this command will auto-generate one. We can use SQLite studio to confirm that the accounts table has been created.

## Changes and Rollbacks

If later down the road, we realize you need to update your schema, you shouldn't edit the migration files. Instead, you will want to create a new migration with the command.

```
knex migrate:make accounts-schema-update
```

Ounce we've written our updates into this file, we save and close with:

```
knex migrate:latest
```

If we migrate our database and then quickly realize something isn't right, we can edit the migration file. However, first we need to **rollback**(undo) our last migration with:

```
knex migrate:rollback
```

Finally, we are free to rerun that file with **knex:migrate latest**

**NOTE** A rollback should not be used to edit an old migration file once that file has accepted into a main branch. However an entire team may use a rollback to return to a previous version of a database.

## Overview

Often we want to pre-populate our database with sample data for testing. Seeds allows us to add and reset sample data easily.

## Follow Along - Seeding

Similar to migrations, we want to customize where our seed files are generated using our knexfile.

```
development: {
    client: 'sqlite3',
    connection: {
      filename: './data/produce.db3',
    },
    useNullAsDefault: true,
    // generates migration files in a data/migrations/ folder
    migrations: {
      directory: './data/migrations'
    },
    seeds: {
      directory: './data/seeds'
    }
  }
  ```

  To create a seed run: **knex seed:make 01-seedName**

  Numbering is a good idea because knex doesn't attach a timestamp to the name like migrate does. Adding numbers to the file name, we can control the order in which they run.

  We want to create a seeds for our accounts table:

  ```
  knex seed:make 001-accounts
  ```

  A file will appear in the designated seed folder.

  ```
  exports.seed = function(knex, Promise) {
  // we want to remove all data before seeding
  // truncate will reset the primary key each time
  return knex('accounts').truncate()
    .then(function () {
      // add data into insert
      return knex('accounts').insert([
        { name: 'Stephenson', budget: 10000 },
        { name: 'Gordon & Gale', budget: 40400 },
      ]);
    });
};
```

Run the seed by typing:

```
knex seed:run
```

You can now use SQLite Studio to confirm that the accounts table has two entries.
